<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>DarkCPU: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DarkCPU
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('threading10c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#mutlithreading">Threading</a><ul><li class="level2"><a href="#lockingthreadm">Locking Thread Manager</a></li>
<li class="level2"><a href="#threadingTeb">TEB</a></li>
<li class="level2"><a href="#threadingContext">ThreadContext</a></li>
</ul>
</li>
<li class="level1"><a href="#DASMDOC_S20">Data</a><ul><li class="level2"><a href="#DASMDOC_S21">threading_activeThread</a></li>
<li class="level2"><a href="#DASMDOC_S22">threading_rootThread</a></li>
<li class="level2"><a href="#DASMDOC_S23">threading_state</a></li>
</ul>
</li>
<li class="level1"><a href="#DASMDOC_S24">Functions</a><ul><li class="level2"><a href="#DASMDOC_S25">threading_endCycle</a></li>
<li class="level2"><a href="#DASMDOC_S26">threading_createThread</a></li>
<li class="level2"><a href="#DASMDOC_S27">threading_createThreadEx</a></li>
<li class="level2"><a href="#DASMDOC_S28">threading_removeThread</a></li>
<li class="level2"><a href="#DASMDOC_S29">threading_lock</a></li>
<li class="level2"><a href="#DASMDOC_S30">threading_free</a></li>
<li class="level2"><a href="#DASMDOC_S31">threading_endOfThread</a></li>
<li class="level2"><a href="#DASMDOC_S32">threading_interrupt</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h2>threading10c</h2>
<p><a class="anchor" id="ThreadingManager"></a></p>
<p>This module is responsible for hadling a large portion of the multithreading in the operating system. This subsystem performs threading operations such as creating or destorying threads, halting/resuming threads, changing a thread's context and swapping threads on interrupt triggers. </p>
<dl class="section author"><dt>Author</dt><dd>Jeremy (0x10cforums.com) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Dec, 15, 2012</dd></dl>
<h1><a class="anchor" id="mutlithreading"></a>
Threading</h1>
<p>A thread in DarkCPU defines a single stream of execution throughout memory. The kernel will swap between these streams of execution very quickly, giving the system an illusion that multiple streams are being executed parallel to one-another. Each stream acts as if it were an individual processor on the system, each with their own ThreadContext structure, descirinbg the execution stream's state of context sinsitive data carried by the cpu such as the registers. Each thread will also have their own stack structure allocated for them as well.</p>
<p>In DarkCPU, threads are specifically just threads. They are not 'owned' by their parent process. Each process can spawn several threads, and a thread can be spawned from no particular process. Threads are commonly used in conjunction with executable images to perform the tasks described by the executable image and are thus used very frequently when developing applications or drivers for the operating system. It is important to note that a thread is not at all required for an application, and the lack of a thread running inside of an application does not make that application any less valid.</p>
<p>The threading manager keeps track of all active threads by sorting a linked list of the threads' ThreadContext strucutres (<a class="el" href="threading10c.html#ThreadContextLayout">ThreadContextLayout</a>), with the root entry of this list defined in the threading_rootThread variable. The threading manager will set threading_activeThread to point to the active thread's ThreadContext structure. When it is time to swap threads, the threading manager will save the state of the active thread into it's respective ThreadContext structure, and walk down the linked list to the next thread. It will then proceed to put the DCPU processor into the state described by that thread's ThreadContext structure, and resume execution.</p>
<p>Each thread is also assigned a unique identification value, which is equal to the base address of their ThreadContext structure in memory.</p>
<p>If there are no registered threads in the system, the threading system will execute the threading_interrupt_idleThread routine, where it waits for a thread to execute.</p>
<p>When the thread's entrypoint returns, the thread returns to threading_endOfThread, where it is destroyed and control is passed on to another thread.</p>
<hr/>
 <h2><a class="anchor" id="lockingthreadm"></a>
Locking Thread Manager</h2>
<p><a class="anchor" id="LockingTheThreadManager"></a>If a given thread is performing a time-sensitive operation or if the thread is accessing a device or memory location and needs to ensure exclusive access to this resource (refer to a higher-level method of doing with with the MutexManager), the threading manager can be placed into a locked state. That is, whichever thread requests a lock, will consistantly be the only thread executing on the system until it has restored the threading manager to an unlocked state. If possible, one should use a Mutex (Mutexes) to ensure synchronization of resource access, however if they are executing outside of a threaded environment or are unable to Initialize the MutexManager, the threading manager can be locked.</p>
<p>The Threading Manager's State can be locked and unlocked by using the threading_lock and threading_free routines respectivley.</p>
<p>The state of the threading manager is stored inside of the threading_state variable.</p>
<hr/>
 <h2><a class="anchor" id="threadingTeb"></a>
TEB</h2>
<dl class="section note"><dt>Note</dt><dd>This has not yet been implemented. The thread environment block is a structure located inside of the TreadContext strucutre. The thread environment block is pointed to by the Z register of the thread when the thread is created. It is the responsiblity of the code to maintain the Z register if it wishes to access the thread context strucutre. All functions in the DCPU kernel assumes the Z register points to the thread's ThreadContext structure when they are entered.</dd></dl>
<hr/>
 <h2><a class="anchor" id="threadingContext"></a>
ThreadContext</h2>
<p><a class="anchor" id="ThreadContextLayout"></a></p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Member Name </th><th>Description of Member</th></tr>
<tr>
<td>THREADCONTEXT_OFFSET_PC </td><td>regPc </td><td>Stores the state of the 'PC' register the last time this thread swapped from being active to inactive. </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_SP </td><td>regSp </td><td>Stores the state of the 'SP' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_EX </td><td>regEx </td><td>Stores the state of the 'EX' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_A </td><td>regA </td><td>Stores the state of the 'A' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_B </td><td>regB </td><td>Stores the state of the 'B' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_C </td><td>regC </td><td>Stores the state of the 'C' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_X </td><td>regX </td><td>Stores the state of the 'Z' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_Y </td><td>regY </td><td>Stores the state of the 'Y' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_Z </td><td>regZ </td><td>Stores the state of the 'Z' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_I </td><td>regI </td><td>Stores the state of the 'I' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_J </td><td>regJ </td><td>Stores the state of the 'J' register the last time this thread swapped from being active to inactive </td></tr>
<tr>
<td>THREADCONTEXT_OFFSET_NEXT </td><td>pNextThread </td><td>Points to the next thread in the linked list of threads, or to THREADING_INVALIDENTRY if the ThreadContext is the last in the list </td></tr>
<tr>
<td>Start of the TEB Block </td><td>N </td><td>N </td></tr>
<tr>
<td>THREADCONTEXT_TEB_OFFSET </td><td>pTeb </td><td>Points to the start of the Thread Environment Block. </td></tr>
<tr>
<td>THREADCONTEXT_TEB_OFFSET_PARENTIMAGE </td><td>pParentImage </td><td>Pointer to the executable image which this thread belongs to, or null if it does not belong to an executable </td></tr>
<tr>
<td>THREADCONTEXT_TEB_OFFSET_SEHCHAIN </td><td>pTebSehChain </td><td>Pointer to the first SEH entry in the thread's SEH chain. Refer to ExceptionManager </td></tr>
<tr>
<td>Start of the Stack Memory Region </td><td>N </td><td>N </td></tr>
<tr>
<td>... </td><td>Thread Stack </td><td>Memory allocated for the thread's stack </td></tr>
<tr>
<td>THREADCONTEXT_OFFSETEND </td><td></td><td>Offset to the last word in the ThreadContext. This is the initial value of SP for the thread. </td></tr>
</table>
<h1><a class="anchor" id="DASMDOC_S20"></a>
Data</h1>
<hr/>
 <h2><a class="anchor" id="DASMDOC_S21"></a>
threading_activeThread</h2>
<p><code>THREADCONTEXT*</code> threading_activeThread <br/>
<br/>
<b>Description:</b><br/>
 Stores a pointer to the currently active thread's ThreadContext structure, or is equal to THREADING_INVALIDENTRY if there are no registered threads. <br/>
<br/>
</p>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">dat THREADING_INVALIDENTRY</div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S22"></a>
threading_rootThread</h2>
<p><code>THREADCONTEXT*</code> threading_rootThread <br/>
<br/>
<b>Description:</b><br/>
 Stores a pointer to the root of the linked list of active threads in the system, or THREADING_INVALIDENTRY if there are no registered threads. <br/>
<br/>
</p>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">dat THREADING_INVALIDENTRY</div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S23"></a>
threading_state</h2>
<p><code>THREADINGSTATE</code> threading_state <br/>
<br/>
<b>Description:</b><br/>
 Stores the current state of the threading system. I.e, THREADING_STATE_NORMAL or THREADING_STATE_LOCKED <br/>
<br/>
</p>
<p><b>Code:</b> </p>
<div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="DASMDOC_S24"></a>
Functions</h1>
<hr/>
 <h2><a class="anchor" id="DASMDOC_S25"></a>
threading_endCycle</h2>
<p><a class="el" href="calling_conventions.html#nakedcall">nakedcall</a> VOID threading_endCycle() <br/>
<br/>
<b>Description:</b><br/>
 Ends the threads current cycle and passes execution on to the next chain. Internally, this just contains the _threading_endCycle() macro followed by a return. If possible, the _threading_endCycle() macro should be used instead to reduce overhead. If the threading system is locked when this function is called, it is automatically freed. <br/>
</p>
<dl class="section return"><dt>Returns</dt><dd><code>VOID</code> No return value. <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">_threading_endCycle()</div>
<div class="line">ret</div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S26"></a>
threading_createThread</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID* threading_createThread(<code>VOID*</code> pEntryPoint, <code>WORD</code> wArgument) <br/>
<br/>
<b>Description:</b><br/>
 Creates a new thread at a specified origin. The thread can also be passed an argument when created which will be stored in its A register. <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntryPoint</td><td><code>VOID*</code> Pointer to where this thread should start executing in memory. The entry point is called with the asyncCall calling convention. </td></tr>
    <tr><td class="paramname">wArgument</td><td><code>WORD</code> Argument to pass to the thread's entrypoint. Refer to <a class="el" href="calling_conventions.html#asynccall">asynccall</a> for details on how this argument is transfered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>VOID*</code> Returns the base address of the thread's ThreadContext structure, which can be interpreted as the threads ID. <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">_sfBegin(0)</div>
<div class="line"></div>
<div class="line">_push [z + THREADCONTEXT_TEB_OFFSET_PARENTIMAGE]</div>
<div class="line">_sfArg(push, 1)</div>
<div class="line">_sfArg(push, 0)</div>
<div class="line">call threading_createThreadEx</div>
<div class="line">add sp, 3</div>
<div class="line"></div>
<div class="line">_sfEnd()</div>
<div class="line">ret</div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S27"></a>
threading_createThreadEx</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID* threading_createThreadEx(<code>VOID*</code> pEntryPoint, <code>WORD</code> wArgument, <code>IMAGE*</code> pParentImage) <br/>
<br/>
<b>Description:</b><br/>
 Creates a new thread at a specified origin. The thread can also be passed an argument when created which will be stored in its A register. <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntryPoint</td><td><code>VOID*</code> Pointer to where this thread should start executing in memory. The entry point is called with the asyncCall calling convention. </td></tr>
    <tr><td class="paramname">wArgument</td><td><code>WORD</code> Argument to pass to the thread's entrypoint. Refer to asyncCall for details on how this argument is transfered. </td></tr>
    <tr><td class="paramname">pParentImage</td><td><code>IMAGE*</code> Pointer to the executable image of this thread's parent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>VOID*</code> Returns the base address of the thread's ThreadContext structure, which can be interpreted as the threads ID. <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">    _sfBegin(0)</div>
<div class="line">    call threading_lock                                             ;Lock the threading system to assure it does not change\access any threading structures as we mutate them.</div>
<div class="line"></div>
<div class="line">    _push THREADCONTEXT_SIZE                                        ;Allocate thread&#39;s ThreadContext structure.</div>
<div class="line">    call memory_allocate</div>
<div class="line">    add sp, 1</div>
<div class="line">    </div>
<div class="line">    _sfArg([a + THREADCONTEXT_OFFSET_PC], 0)                        ;Set the thread&#39;s TheadContext&#39;s regPc to the first argument, pEntryPoint, so that when it is swapped to, it begins executing at that address.</div>
<div class="line">    _sfArg([a + THREADCONTEXT_OFFSET_A], 1)                         ;Set the thread&#39;s TheadContext&#39;s regA to the secont argument, wArgument, so that when it is swapped to, it begins executing with the &#39;A&#39; register equal to the argument passed to the thread.</div>
<div class="line">    _sfArg([a + THREADCONTEXT_TEB_OFFSET_PARENTIMAGE], 2)           ;Set the thread&#39;s ThreadContext TEB&#39;s to reference a parent executabe image described in the arguments.</div>
<div class="line">    </div>
<div class="line">    set [a + THREADCONTEXT_OFFSET_Z], a                             ;Setup Z register such that it points to the thread&#39;s ThreadContext structure.</div>
<div class="line">    </div>
<div class="line">    set [a + THREADCONTEXT_OFFSET_NEXT], THREADING_INVALIDENTRY     ;Assure that the NEXT entry of this thread is invalid (i.e, it is the last entry in the linked list)</div>
<div class="line">    </div>
<div class="line">    ;Below code &#39;pushes&#39; a return address of threading_endOfThread onto the stack.</div>
<div class="line">    set c, a</div>
<div class="line">    add c, THREADCONTEXT_OFFSET_END</div>
<div class="line">    set [c], threading_endOfThread</div>
<div class="line">    set [a + THREADCONTEXT_OFFSET_SP], c</div>
<div class="line">    </div>
<div class="line">    ;Loop attempts to append thread to linked list of threads.</div>
<div class="line">    ife [threading_rootThread], THREADING_INVALIDENTRY              ;If the root thread is invalid (i.e, there are no active threads on the system.)</div>
<div class="line">        jmp threading_createThreadEx_rootEntry                      ;Set this new thread as the root thread.</div>
<div class="line">        </div>
<div class="line">    set y, [threading_rootThread]                                   ;Otherwise iterate over threads in linked list and look for one that has a free next entry (i.e, a next entry that is not valid) and link our new thread to that one.</div>
<div class="line">    </div>
<div class="line">    threading_createThreadEx_seekLastLoop:</div>
<div class="line">        ife [y + THREADCONTEXT_OFFSET_NEXT],  THREADING_INVALIDENTRY</div>
<div class="line">            jmp threading_createThreadEx_createEntry</div>
<div class="line">            </div>
<div class="line">        set y, [y + THREADCONTEXT_OFFSET_NEXT]</div>
<div class="line">        jmp threading_createThreadEx_seekLastLoop</div>
<div class="line">        </div>
<div class="line">threading_createThreadEx_createEntry:</div>
<div class="line">    set [y + THREADCONTEXT_OFFSET_NEXT], a</div>
<div class="line">    jmp threading_createThreadEx_end</div>
<div class="line">        </div>
<div class="line">threading_createThreadEx_rootEntry:</div>
<div class="line">    set [threading_rootThread], a</div>
<div class="line">    </div>
<div class="line">threading_createThreadEx_end:</div>
<div class="line">    _push a</div>
<div class="line">    call threading_free</div>
<div class="line">    _pop a</div>
<div class="line">        </div>
<div class="line">    _sfEnd()</div>
<div class="line">    ret</div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S28"></a>
threading_removeThread</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> STATUS threading_removeThread(<code>THREADCONTEXT*</code> pThreadContext) <br/>
<br/>
<b>Description:</b><br/>
 Removes a specified thread from the linked list of threads, and deallocates its ThreadContext structure. If this thread is the active thread, the thread is removed and control is passed on to the next thread in the list. <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThreadContext</td><td><code>THREADCONTEXT*</code> A pointer to the threads ThreadContext structure, otherwise known as the thread's ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>STATUS</code> Returns 0 on error, and anything else otherwise. <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">    _sfBegin(0)</div>
<div class="line">    call threading_lock ;Must be done do avoid half a threading entry from being deleted.</div>
<div class="line">    </div>
<div class="line">    set a, 0 ;design of routine counts on the fact that this register is not used unless there were no errors</div>
<div class="line">             ;and that if there aren&#39;t errors, it is set to something other than 0</div>
<div class="line">             </div>
<div class="line">    set y, [threading_rootThread]</div>
<div class="line">    </div>
<div class="line">    ; If thread being removed equals the active thread</div>
<div class="line">    ; Set active thread to INVALIDENTRY</div>
<div class="line">    _sfArg(c, 0)</div>
<div class="line">    ife c, [threading_activeThread]</div>
<div class="line">        set [threading_activeThread], THREADING_INVALIDENTRY</div>
<div class="line">        </div>
<div class="line">    ; If thread being removed is the root entry</div>
<div class="line">    ife y, c</div>
<div class="line">        jmp threading_removeThread_removeRoot ;Skip the search and remove the root entry.</div>
<div class="line">        </div>
<div class="line">    threading_removeThread_seekParentThreadLoop:</div>
<div class="line">        ife [y + THREADCONTEXT_OFFSET_NEXT],  THREADING_INVALIDENTRY</div>
<div class="line">            jmp threading_removeThread_endOfList</div>
<div class="line">            </div>
<div class="line">        ife [y + THREADCONTEXT_OFFSET_NEXT],  c</div>
<div class="line">            jmp threading_removeThread_seekParentThreadLoop_end</div>
<div class="line">        </div>
<div class="line">        set y, [y + THREADCONTEXT_OFFSET_NEXT]</div>
<div class="line">        jmp threading_removeThread_seekParentThreadLoop</div>
<div class="line">        </div>
<div class="line">threading_removeThread_seekParentThreadLoop_end:</div>
<div class="line">    set [y + THREADCONTEXT_OFFSET_NEXT], [c + THREADCONTEXT_OFFSET_NEXT]</div>
<div class="line">    </div>
<div class="line">threading_removeThread_removeEntry:</div>
<div class="line">    _push THREADCONTEXT_SIZE</div>
<div class="line">    _push c</div>
<div class="line">    call memory_free</div>
<div class="line">    add sp, 2</div>
<div class="line">    </div>
<div class="line">threading_removeThread_endOfList:   ;NOTE ABOVE TO A REGISTER</div>
<div class="line">    </div>
<div class="line">    ;If active thread is now invalid (due to our remove operation)</div>
<div class="line">    ;pass control to to next thread</div>
<div class="line">    ife [threading_activeThread], THREADING_INVALIDENTRY</div>
<div class="line">        _threading_endCycle()</div>
<div class="line">        </div>
<div class="line">    jmp threading_free ;if jumped to due to error, &#39;A&#39; register should be zero</div>
<div class="line">    ret</div>
<div class="line"></div>
<div class="line">threading_removeThread_removeRoot:</div>
<div class="line">    set [threading_rootThread], [y + THREADCONTEXT_OFFSET_NEXT]</div>
<div class="line">    jmp threading_removeThread_removeEntry</div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S29"></a>
threading_lock</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID threading_lock() <br/>
<br/>
<b>Description:</b><br/>
 Locks the threading manager such that the calling thread is the only thread executed on the system until the threading system is freed. Regier to <a class="el" href="threading10c.html#LockingTheThreadManager">LockingTheThreadManager</a> <br/>
</p>
<dl class="section return"><dt>Returns</dt><dd><code>VOID</code> No return data. <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line"><span class="keyword">set</span> [threading_state], THREADING_STATE_LOCKED</div>
<div class="line">ret</div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S30"></a>
threading_free</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID threading_free() <br/>
<br/>
<b>Description:</b><br/>
 Releases the threading manager placing it back into its normal state. All threads will execute on the system and the calling thread may be interrupted at any time. Regier to <a class="el" href="threading10c.html#LockingTheThreadManager">LockingTheThreadManager</a> <br/>
</p>
<dl class="section return"><dt>Returns</dt><dd><code>VOID</code> No return data. <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line"><span class="keyword">set</span> [threading_state], THREADING_STATE_NORMAL</div>
<div class="line">ret </div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S31"></a>
threading_endOfThread</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID threading_endOfThread() <br/>
<br/>
<b>Description:</b><br/>
 Once a thread has finished performing its task, and returns from its path of execution, it will return to this function. Here the thread will be destroyed. <br/>
</p>
<dl class="section return"><dt>Returns</dt><dd><code>VOID</code> No return data. <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line"><span class="keyword">set</span> a, sp                   ; <span class="charliteral">&#39;A&#39;</span> <span class="keyword">register</span> will be equal to address of last data member in structure + 1 (because it just popped off the <span class="keywordflow">return</span>)</div>
<div class="line">sub a, THREADCONTEXT_SIZE   ;because it is equal to last data + 1, it is effectivley base + the size of the structure</div>
<div class="line">_push A</div>
<div class="line">call threading_removeThread</div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S32"></a>
threading_interrupt</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID threading_interrupt() <br/>
<br/>
<b>Description:</b><br/>
 Invoked by the ClockDriver on equal intervals. When invoked, this routine is tasked with the procedure of determining if control should be passed to the next thread, and passing control if it should <br/>
</p>
<dl class="section return"><dt>Returns</dt><dd><code>VOID</code> No return data. <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">    ife [threading_state], THREADING_STATE_LOCKED</div>
<div class="line">        rfi A</div>
<div class="line">    </div>
<div class="line">    ife [threading_activeThread], THREADING_INVALIDENTRY</div>
<div class="line">        jmp threading_interrupt_skipStore</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">set</span> A, [threading_activeThread]</div>
<div class="line">    _pop [a + THREADCONTEXT_OFFSET_A]   ;Pop the A <span class="keyword">register</span> and PC from stack, refer to naked-isr convention</div>
<div class="line">    _pop [a + THREADCONTEXT_OFFSET_PC]</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">set</span> [a + THREADCONTEXT_OFFSET_EX], EX</div>
<div class="line">    <span class="keyword">set</span> [a + THREADCONTEXT_OFFSET_SP], SP</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">set</span> [a + THREADCONTEXT_OFFSET_B], B</div>
<div class="line">    <span class="keyword">set</span> [a + THREADCONTEXT_OFFSET_C], C</div>
<div class="line">    <span class="keyword">set</span> [a + THREADCONTEXT_OFFSET_X], Z</div>
<div class="line">    <span class="keyword">set</span> [a + THREADCONTEXT_OFFSET_Y], Y</div>
<div class="line">    <span class="keyword">set</span> [a + THREADCONTEXT_OFFSET_Z], Z</div>
<div class="line">    <span class="keyword">set</span> [a + THREADCONTEXT_OFFSET_I], I</div>
<div class="line">    <span class="keyword">set</span> [a + THREADCONTEXT_OFFSET_J], J</div>
<div class="line"></div>
<div class="line">    jmp threading_interrupt_endOfThreadStore</div>
<div class="line">    </div>
<div class="line">threading_interrupt_skipStore:</div>
<div class="line">    add sp, 2   ; POP A and PC off of stack.</div>
<div class="line"></div>
<div class="line">threading_interrupt_endOfThreadStore:</div>
<div class="line">    <span class="keyword">set</span> A, [threading_activeThread]</div>
<div class="line">    </div>
<div class="line">    ifn a, THREADING_INVALIDENTRY</div>
<div class="line">        <span class="keyword">set</span> [threading_activeThread], [a+ THREADCONTEXT_OFFSET_NEXT]</div>
<div class="line">        </div>
<div class="line">    ife [threading_activeThread], THREADING_INVALIDENTRY</div>
<div class="line">        <span class="keyword">set</span> [threading_activeThread], [threading_rootThread]</div>
<div class="line">    </div>
<div class="line">    ife [threading_activeThread], THREADING_INVALIDENTRY</div>
<div class="line">        jmp threading_interrupt_idleThread</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">set</span> a, [threading_activeThread]</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">set</span> j, [a+ THREADCONTEXT_OFFSET_J]</div>
<div class="line">    <span class="keyword">set</span> i, [a+ THREADCONTEXT_OFFSET_I]</div>
<div class="line">    <span class="keyword">set</span> z, [a+ THREADCONTEXT_OFFSET_Z]</div>
<div class="line">    <span class="keyword">set</span> y, [a+ THREADCONTEXT_OFFSET_Y]</div>
<div class="line">    <span class="keyword">set</span> x, [a+ THREADCONTEXT_OFFSET_X]</div>
<div class="line">    <span class="keyword">set</span> b, [a+ THREADCONTEXT_OFFSET_B]</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">set</span> ex, [a+ THREADCONTEXT_OFFSET_EX]</div>
<div class="line">    <span class="keyword">set</span> sp, [a+ THREADCONTEXT_OFFSET_SP]</div>
<div class="line">    </div>
<div class="line">    add a, THREADCONTEXT_OFFSET_PC</div>
<div class="line">    </div>
<div class="line">    _push [a] ; Push the thread<span class="stringliteral">&#39;s pc to the stack</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    set a,  [a+ THREADCONTEXT_OFFSET_A] ;Set a register appropriately</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    iaq 0 ; re-enable interrupts before returning to new thread.</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    jmp pop ; pop it off an jump to its pc.</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">threading_interrupt_idleThread:</span></div>
<div class="line"><span class="stringliteral">    call threading_free</span></div>
<div class="line"><span class="stringliteral">    iaq 0 ; re-enable interrupts</span></div>
<div class="line"><span class="stringliteral">    sub pc, 1 </span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="md__code.html">Code</a></li>
    <li class="footer">Generated on Tue Apr 9 2013 21:10:06 for DarkCPU by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
