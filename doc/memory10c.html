<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>DarkCPU: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DarkCPU
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('memory10c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#memoryManager">Memory Manager</a><ul><li class="level2"><a href="#memoryManagerDetails">Memory Management</a></li>
<li class="level2"><a href="#memoryManagerReservingMemory">Reserving Manager</a></li>
<li class="level2"><a href="#memoryManagerMemorySwapping">Memory Swapping</a></li>
</ul>
</li>
<li class="level1"><a href="#DASMDOC_S65">Constants</a><ul><li class="level2"><a href="#DASMDOC_S66">MEMORY_CHUNK_SIZE</a></li>
<li class="level2"><a href="#DASMDOC_S67">MEMORY_MAX_CHUNKS</a></li>
<li class="level2"><a href="#DASMDOC_S68">MEMORY_CHUNK_LASTINDEX</a></li>
<li class="level2"><a href="#DASMDOC_S69">MEMORY_ALLOCATIONBITMAP_SIZE</a></li>
</ul>
</li>
<li class="level1"><a href="#DASMDOC_S70">Data</a><ul><li class="level2"><a href="#DASMDOC_S71">memory_allocationBitmap</a></li>
<li class="level2"><a href="#DASMDOC_S72">memory_accessMutex</a></li>
</ul>
</li>
<li class="level1"><a href="#DASMDOC_S73">Functions</a><ul><li class="level2"><a href="#DASMDOC_S74">memory_init</a></li>
<li class="level2"><a href="#DASMDOC_S75">memory_reserve</a></li>
<li class="level2"><a href="#DASMDOC_S76">memory_allocate</a></li>
<li class="level2"><a href="#DASMDOC_S77">memory_free</a></li>
<li class="level2"><a href="#DASMDOC_S78">memory_copy</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h2>memory10c</h2>
<h1><a class="anchor" id="memoryManager"></a>
Memory Manager</h1>
<h2><a class="anchor" id="memoryManagerDetails"></a>
Memory Management</h2>
<p>This subsystem performs memory operations such as allocation, freeing and reserving of memory. </p>
<dl class="section author"><dt>Author</dt><dd>Jeremy (0x10cforums.com) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Dec, 15, 2012</dd></dl>
<h2><a class="anchor" id="memoryManagerDetails"></a>
Memory Management</h2>
<p>The memory manager (MemoryManager) in DarkCPU is responsible for allocating, freeing and protecting memory inside of the system. All memory inside of DarkCPU divided into sections referred to as memory chunks, which are a given words division of memory. The particular size of a memory chunk is defined by MEMORY_CHUNK_SIZE The state of each memory section is defined inside of the memory_allocationBitmap. Where the first bit in the bitmap defines the state of the first memory chunk, and the next bit defines the state of the following memory chunk, etc...</p>
<p>When the user requests to allocate a region memory of a given size, the memory manager will round up the size such that it aligns to the size of a memory chunck. I.e, allocating 1 word via the memory manager will actually result in a memory allocation of MEMORY_CHUNK_SIZE words. This is done to minimize the size of the allocation table and maximize the number of possible memory divisions.</p>
<hr/>
<h2><a class="anchor" id="memoryManagerReservingMemory"></a>
Reserving Manager</h2>
<p>The DarkCPU Memory Manager allows the user to reserve a region of memory. A reserved memory region is ignored by the memory manager and treated as if it hadn't even existed in the first place. The BootCode uses this routine of the memory manager to reserve the region of memory the kernel image has been loaded into.</p>
<dl class="section attention"><dt>Attention</dt><dd>It is important to note that reserving memory does not guarantee that the memory region being reserved has not already been allocated or reserved. I.e, it is important to be aware of what lies inside of the memory region you are reserving. <hr/>
</dd></dl>
<h2><a class="anchor" id="memoryManagerMemorySwapping"></a>
Memory Swapping</h2>
<dl class="section note"><dt>Note</dt><dd>This has not yet been implemented</dd></dl>
<p>Memory Swapping is an effective way for the DCPU kernel to maximize the use of its memory without an MMU. It allows on-demand defragmentation of memory, allowing more contiguous regions of memory to exist and allowing the system to allocate more memory than is physically accessible. The swapping system works by allowing the user to allocate swapped memory. Swapped memory is a special kind of memory in the DarkCPU kernel as will be described below. Swapped memory can be placed in either a locked or unlocked state.</p>
<p>When the user initially allocates a swapped memory region, it is placed in an unlocked state, which means it has no valid base address and that the memory region does not exist in memory.</p>
<p>After placing the swapped memory region into a locked state via one of the swapped memory locking routines, it will be loaded at a given base address in memory. The specific address it is loaded at will be provided by the locking routine.</p>
<p>The user may then continue to mutate or read the data region, as if it were a normal region of allocated memory. Once the application has finished working with the memory, it can be placed into an 'unlocked' state.</p>
<p>When a swapped memory region is unlocked, it is not expected to be read from or written to and thus the kernel assumes that, if need be, the memory region can be relocated or swapped out on to another storage device. When the memory region is locked again, the kernel will assure it is loaded back into memory and will provide the caller of the locking routine the details regarding which base address it is loaded at.</p>
<dl class="section note"><dt>Note</dt><dd>Wherever possible, swapped memory should be used over the primitive memory allocation methods for reasons described above.</dd>
<dd>
Just because a swapped memory region is in an unlocked state, does not mean that the kernel will swap it out of memory. In all likelihood, if the system is not pressed for memory and the memory is not too poorly fragmented, the data region will be left untouched to optimize the locking procedure. However this is not guaranteed and the user should not assume that is hasn't been swapped out.</dd></dl>
<h1><a class="anchor" id="DASMDOC_S65"></a>
Constants</h1>
<hr/>
 <h2><a class="anchor" id="DASMDOC_S66"></a>
MEMORY_CHUNK_SIZE</h2>
<p><code>WORD</code> MEMORY_CHUNK_SIZE <br/>
<br/>
<b>Description:</b><br/>
 Defines the size of a single memory chunk in words. <br/>
<br/>
</p>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MEMORY_CHUNK_SIZE 64</span></div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S67"></a>
MEMORY_MAX_CHUNKS</h2>
<p><code>WORD</code> MEMORY_MAX_CHUNKS <br/>
<br/>
<b>Description:</b><br/>
 Defines the maximum number of memory chuncks which can be allocated. I.e, the number of memory chuncks which constitute the system memory. <br/>
<br/>
</p>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MEMORY_MAX_CHUNKS 1024</span></div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S68"></a>
MEMORY_CHUNK_LASTINDEX</h2>
<p><code>WORD</code> MEMORY_CHUNK_LASTINDEX <br/>
<br/>
<b>Description:</b><br/>
 Defines the index of the last memory chunk in memory. <br/>
<br/>
</p>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MEMORY_CHUNK_LASTINDEX 1023</span></div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S69"></a>
MEMORY_ALLOCATIONBITMAP_SIZE</h2>
<p><code>WORD</code> MEMORY_ALLOCATIONBITMAP_SIZE <br/>
<br/>
<b>Description:</b><br/>
 Defines the size of the internal allocation bitmap in words. <br/>
<br/>
</p>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MEMORY_ALLOCATIONBITMAP_SIZE 64</span></div>
</div><!-- fragment --><h1><a class="anchor" id="DASMDOC_S70"></a>
Data</h1>
<hr/>
 <h2><a class="anchor" id="DASMDOC_S71"></a>
memory_allocationBitmap</h2>
<p><code>WORD*</code> memory_allocationBitmap <br/>
<br/>
<b>Description:</b><br/>
 Consists of a series of words which create the allocation bitmap. <br/>
<br/>
</p>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000</div>
<div class="line">dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000</div>
<div class="line">dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000</div>
<div class="line">dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000</div>
<div class="line">dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000</div>
<div class="line">dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000</div>
<div class="line">dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000</div>
<div class="line">dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 </div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S72"></a>
memory_accessMutex</h2>
<p><code>MUTEX*</code> memory_accessMutex <br/>
<br/>
<b>Description:</b><br/>
 The mutex object used to synchronize threads accessing the memory manager. I.e, to avoid two threads allocating memory at the same time. Which might result in one or the other from allocating the same region of memory. <br/>
<br/>
</p>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">dat 0x0000</div>
</div><!-- fragment --><h1><a class="anchor" id="DASMDOC_S73"></a>
Functions</h1>
<hr/>
 <h2><a class="anchor" id="DASMDOC_S74"></a>
memory_init</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID memory_init() <br/>
<br/>
<b>Description:</b><br/>
 This routine is responsible for initilizing the memory manager and must be invoked prior to any other calls beloning to the memory manager module. This routine must be called only once during initilization. Typically, this is done inside of the BootCode. Outside of the BootCode, this routine should not be called. <br/>
</p>
<dl class="section return"><dt>Returns</dt><dd><code>VOID</code> <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">call mutex_create               ; Create the memory manager<span class="stringliteral">&#39;s access mutex. This is used to synchronize memory management operations so they do not conflict.</span></div>
<div class="line"><span class="stringliteral">set [memory_accessMutex], a</span></div>
<div class="line"><span class="stringliteral">ret </span></div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S75"></a>
memory_reserve</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID memory_reserve(<code>WORD*</code> pBaseAddress, <code>WORD</code> wSize) <br/>
<br/>
<b>Description:</b><br/>
 This routine is responsible for reserving memory, that is, keeping the memory manager from opening such memory for allocation. Refer to ReservingMemory <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBaseAddress</td><td><code>WORD*</code> A pointer to base of the memory region being reserved </td></tr>
    <tr><td class="paramname">wSize</td><td><code>WORD</code> The size of the memory region to reserve. This is rounded upwards to aligned with a memory chunck. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>VOID</code> <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">_sfBegin(0)</div>
<div class="line"></div>
<div class="line">_push [memory_accessMutex]          ; Lock the memory access mutex to assure we are the only thread executing inside of this routine</div>
<div class="line">call mutex_lock</div>
<div class="line">add sp, 1</div>
<div class="line"></div>
<div class="line">_sfArg(c, 0)</div>
<div class="line">_sfArg(a, 1)</div>
<div class="line"></div>
<div class="line">div c, MEMORY_CHUNK_SIZE            ; Translating location in terms of chunks</div>
<div class="line"></div>
<div class="line">div a, MEMORY_CHUNK_SIZE            ; Translating size in terms of chunks</div>
<div class="line">ifn ex, 0</div>
<div class="line">    add a, 1</div>
<div class="line"></div>
<div class="line">_push 0</div>
<div class="line">_push a                             ;Push the number of bits in length of our run (equal to the number of memory chunks allocated by the memory region.)</div>
<div class="line">_push c                             ;Push the base index (the first bit that defines our memory region) to the stack.</div>
<div class="line">_push memory_allocationBitmap</div>
<div class="line">call bitmap_nandRun</div>
<div class="line">add sp, 4</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">_push [memory_accessMutex]</div>
<div class="line">call mutex_release</div>
<div class="line">add sp, 1</div>
<div class="line"></div>
<div class="line">_sfEnd()</div>
<div class="line">ret </div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S76"></a>
memory_allocate</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> WORD* memory_allocate(<code>WORD</code> wSize) <br/>
<br/>
<b>Description:</b><br/>
 Allocates a specified region of memory. <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wSize</td><td><code>WORD</code> The size of the memory region to be allocated. This is rounded upwards to aligned with a memory chunck. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>WORD*</code> Returns the base address of the newly allocated region of memory, or 0xFFFF is there is an insufficient amount of contigous memory chucks available for the allocation operation to succeed. <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">    _sfBegin(0)</div>
<div class="line">    </div>
<div class="line">    ;Lock the access mutex to prevent multiple threads from executing <span class="keyword">this</span> routine at a time. Which would result in a collision of allocation.</div>
<div class="line">    _push [memory_accessMutex]</div>
<div class="line">    call mutex_lock</div>
<div class="line">    add sp, 1</div>
<div class="line">    </div>
<div class="line">    _sfArg(c, 0)                                ;Calculate the size of the allocation in terms of memory chuncks.</div>
<div class="line">    div c, MEMORY_CHUNK_SIZE</div>
<div class="line">    ifn ex, 0</div>
<div class="line">        add c, 1</div>
<div class="line">        </div>
<div class="line">    _push c</div>
<div class="line">    _push MEMORY_ALLOCATIONBITMAP_SIZE</div>
<div class="line">    _push memory_allocationBitmap</div>
<div class="line">    call bitmap_findClearRun                    ;Find a clear run of bits with x free entries, where <span class="charliteral">&#39;x&#39;</span> is the number of memory chuncks which constitute the newly allocated memory region<span class="stringliteral">&#39;s size.</span></div>
<div class="line"><span class="stringliteral">    add sp, 3                                   ;Cleanup all the arguments, with the exception of the last one pushed, which is equal to the size of region we allocated. If allocation succeeds, this is used to make the appropriate call to reserve the memory.</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    ife a, 0xFFFF                               ; if no run was found, return to the caller with the error status in &#39;</span>a<span class="stringliteral">&#39;, which is 0xFFFF</span></div>
<div class="line"><span class="stringliteral">        jmp memory_allocateMemory_end</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    ;Otherwise, reserve the memory region and return to the caller</span></div>
<div class="line"><span class="stringliteral">    _push a                                     ;Preserve the state of &#39;</span>A<span class="stringliteral">&#39; as it contains the number of bit index that defines the origin of our allocation. We need this to calculate the address our memory was allocated at.</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    _push 0x0000</span></div>
<div class="line"><span class="stringliteral">    _push c                                     ;Push the number of bits in length of our run (equal to the number of memory chunks allocated by the memory region.</span></div>
<div class="line"><span class="stringliteral">    _push a                                     ;Push the base index (the first bit that defines our memory region) to the stack.</span></div>
<div class="line"><span class="stringliteral">    _push memory_allocationBitmap</span></div>
<div class="line"><span class="stringliteral">    call bitmap_nandRun</span></div>
<div class="line"><span class="stringliteral">    add sp, 4</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">memory_allocateMemory_end:</span></div>
<div class="line"><span class="stringliteral">    _push [memory_accessMutex]                  ;Release the access mutex so that reserve memory can gain exlcusive access to the memory region</span></div>
<div class="line"><span class="stringliteral">    call mutex_release</span></div>
<div class="line"><span class="stringliteral">    add sp, 1</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    _pop a</span></div>
<div class="line"><span class="stringliteral">    mul a, MEMORY_CHUNK_SIZE</span></div>
<div class="line"><span class="stringliteral">    _sfEnd()</span></div>
<div class="line"><span class="stringliteral">    ret</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">memory_allocateMemory_noMemory:</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    set a, 0xFFFF                               ;return 0xFFFF to symbolize that there was an error allocating memory.</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    jmp memory_allocateMemory_end    </span></div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S77"></a>
memory_free</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID memory_free(<code>WORD*</code> pBaseAddress, <code>WORD</code> wSize) <br/>
<br/>
<b>Description:</b><br/>
 Frees a previously allocated region of memory <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBaseAddress</td><td><code>WORD*</code> Specifies the base address of the memory region to be freed </td></tr>
    <tr><td class="paramname">wSize</td><td><code>WORD</code> The size of the memory region to be freed. This is rounded upwards to aligned with a memory chunck. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>VOID</code> <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">_sfBegin(0)</div>
<div class="line"></div>
<div class="line">_push [memory_accessMutex]          ; Lock the memory access mutex to assure we are the only thread executing inside of this routine</div>
<div class="line">call mutex_lock</div>
<div class="line">add sp, 1</div>
<div class="line"></div>
<div class="line">_sfArg(c, 0)</div>
<div class="line">_sfArg(a, 1)</div>
<div class="line"></div>
<div class="line">div c, MEMORY_CHUNK_SIZE            ; Translating location in terms of chunks</div>
<div class="line"></div>
<div class="line">div a, MEMORY_CHUNK_SIZE            ; Translating size in terms of chunks</div>
<div class="line">ifn ex, 0</div>
<div class="line">    add a, 1</div>
<div class="line"></div>
<div class="line">_push 0xFFFF</div>
<div class="line">_push a                             ;Push the number of bits in length of our run (equal to the number of memory chunks allocated by the memory region.)</div>
<div class="line">_push c                             ;Push the base index (the first bit that defines our memory region) to the stack.</div>
<div class="line">_push memory_allocationBitmap</div>
<div class="line">call bitmap_nandRun</div>
<div class="line">add sp, 4</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">_push [memory_accessMutex]</div>
<div class="line">call mutex_release</div>
<div class="line">add sp, 1</div>
<div class="line"></div>
<div class="line">_sfEnd()</div>
<div class="line">ret </div>
</div><!-- fragment --><hr/>
 <h2><a class="anchor" id="DASMDOC_S78"></a>
memory_copy</h2>
<p><a class="el" href="calling_conventions.html#cdecl">cdecl</a> VOID memory_copy(<code>WORD*</code> pDest, <code>WORD*</code> pSrc, <code>WORD</code> wSize) <br/>
<br/>
<b>Description:</b><br/>
 Coppies a series of words from one region to another. <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDest</td><td><code>WORD*</code> Specifies the base address of the memory region to copy to </td></tr>
    <tr><td class="paramname">pSrc</td><td><code>WORD*</code> Specifies the base address of the memory region to copy from </td></tr>
    <tr><td class="paramname">wSize</td><td><code>WORD</code> The size of the memory region to copy in words. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>VOID</code> <br/>
</dd></dl>
<p><b>Code:</b> </p>
<div class="fragment"><div class="line">    _sfBegin(0)</div>
<div class="line">    _push i</div>
<div class="line">    _push j</div>
<div class="line">    </div>
<div class="line">    _sfArg(a, 2)</div>
<div class="line">    _sfArgAdd(a, 0)</div>
<div class="line">    </div>
<div class="line">    _sfArg(i, 0) ; i is dest</div>
<div class="line">    _sfArg(j, 1) ; j is src</div>
<div class="line">    </div>
<div class="line">    memory_copy_loop:</div>
<div class="line">        ife i, a</div>
<div class="line">            jmp memory_copy_end</div>
<div class="line"></div>
<div class="line">        sti [i], [j]</div>
<div class="line">        </div>
<div class="line">        jmp memory_copy_loop</div>
<div class="line">    </div>
<div class="line">memory_copy_end:</div>
<div class="line">    _pop j</div>
<div class="line">    _pop i</div>
<div class="line">    _sfEnd()</div>
<div class="line">    ret</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="md__code.html">Code</a></li>
    <li class="footer">Generated on Sat Apr 13 2013 17:37:42 for DarkCPU by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
